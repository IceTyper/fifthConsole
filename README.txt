5 лабораторная:

Реализовать консольное приложение, которое реализует управление коллекцией объектов в интерактивном режиме. В коллекции необходимо хранить объекты класса SpaceMarine, описание которого приведено ниже.

Разработанная программа должна удовлетворять следующим требованиям:

Класс, коллекцией экземпляров которого управляет программа, должен реализовывать сортировку по умолчанию.
Все требования к полям класса (указанные в виде комментариев) должны быть выполнены.
Для хранения необходимо использовать коллекцию типа java.util.ArrayDequeue
При запуске приложения коллекция должна автоматически заполняться значениями из файла.
Имя файла должно передаваться программе с помощью: аргумент командной строки.
Данные должны храниться в файле в формате json
Чтение данных из файла необходимо реализовать с помощью класса java.io.BufferedInputStream
Запись данных в файл необходимо реализовать с помощью класса java.io.BufferedWriter
Все классы в программе должны быть задокументированы в формате javadoc.
Программа должна корректно работать с неправильными данными (ошибки пользовательского ввода, отсутсвие прав доступа к файлу и т.п.).
В интерактивном режиме программа должна поддерживать выполнение следующих команд:

help : вывести справку по доступным командам
info : вывести в стандартный поток вывода информацию о коллекции (тип, дата инициализации, количество элементов и т.д.)
show : вывести в стандартный поток вывода все элементы коллекции в строковом представлении
add {element} : добавить новый элемент в коллекцию
update id {element} : обновить значение элемента коллекции, id которого равен заданному
remove_by_id id : удалить элемент из коллекции по его id
clear : очистить коллекцию
save : сохранить коллекцию в файл
execute_script file_name : считать и исполнить скрипт из указанного файла. В скрипте содержатся команды в таком же виде, в котором их вводит пользователь в интерактивном режиме.
exit : завершить программу (без сохранения в файл)
remove_head : вывести первый элемент коллекции и удалить его
add_if_max {element} : добавить новый элемент в коллекцию, если его значение превышает значение наибольшего элемента этой коллекции
remove_lower {element} : удалить из коллекции все элементы, меньшие, чем заданный
sum_of_health : вывести сумму значений поля health для всех элементов коллекции
filter_greater_than_melee_weapon meleeWeapon : вывести элементы, значение поля meleeWeapon которых больше заданного
print_field_ascending_health : вывести значения поля health всех элементов в порядке возрастания
Формат ввода команд:

Все аргументы команды, являющиеся стандартными типами данных (примитивные типы, классы-оболочки, String, классы для хранения дат), должны вводиться в той же строке, что и имя команды.
Все составные типы данных (объекты классов, хранящиеся в коллекции) должны вводиться по одному полю в строку.
При вводе составных типов данных пользователю должно показываться приглашение к вводу, содержащее имя поля (например, "Введите дату рождения:")
Если поле является enum'ом, то вводится имя одной из его констант (при этом список констант должен быть предварительно выведен).
При некорректном пользовательском вводе (введена строка, не являющаяся именем константы в enum'е; введена строка вместо числа; введённое число не входит в указанные границы и т.п.) должно быть показано сообщение об ошибке и предложено повторить ввод поля.
Для ввода значений null использовать пустую строку.
Поля с комментарием "Значение этого поля должно генерироваться автоматически" не должны вводиться пользователем вручную при добавлении.
Описание хранимых в коллекции классов:

public class SpaceMarine {
    private int id; //Значение поля должно быть больше 0, Значение этого поля должно быть уникальным, Значение этого поля должно генерироваться автоматически
    private String name; //Поле не может быть null, Строка не может быть пустой
    private Coordinates coordinates; //Поле не может быть null
    private java.time.LocalDate creationDate; //Поле не может быть null, Значение этого поля должно генерироваться автоматически
    private Double health; //Поле не может быть null, Значение поля должно быть больше 0
    private Boolean loyal; //Поле может быть null
    private Weapon weaponType; //Поле может быть null
    private MeleeWeapon meleeWeapon; //Поле может быть null
    private Chapter chapter; //Поле не может быть null
}
public class Coordinates {
    private int x; //Значение поля должно быть больше -928
    private Long y; //Поле не может быть null
}
public class Chapter {
    private String name; //Поле не может быть null, Строка не может быть пустой
    private long marinesCount; //Значение поля должно быть больше 0, Максимальное значение поля: 1000
    private String world; //Поле может быть null
}
public enum Weapon {
    HEAVY_BOLTGUN,
    GRAV_GUN,
    HEAVY_FLAMER;
}
public enum MeleeWeapon {
    CHAIN_SWORD,
    LIGHTING_CLAW,
    POWER_FIST;
}

6 лабораторная:

Разделить программу из лабораторной работы №5 на клиентский и серверный модули. Серверный модуль должен осуществлять выполнение команд по управлению коллекцией. Клиентский модуль должен в интерактивном режиме считывать команды, передавать их для выполнения на сервер и выводить результаты выполнения.

Необходимо выполнить следующие требования:

Операции обработки объектов коллекции должны быть реализованы с помощью Stream API с использованием лямбда-выражений.
Объекты между клиентом и сервером должны передаваться в сериализованном виде.
Объекты в коллекции, передаваемой клиенту, должны быть отсортированы по названию
Клиент должен корректно обрабатывать временную недоступность сервера.
Обмен данными между клиентом и сервером должен осуществляться по протоколу UDP
Для обмена данными на сервере необходимо использовать сетевой канал
Для обмена данными на клиенте необходимо использовать датаграммы
Сетевые каналы должны использоваться в неблокирующем режиме.


Обязанности серверного приложения:

Работа с файлом, хранящим коллекцию.
Управление коллекцией объектов.
Назначение автоматически генерируемых полей объектов в коллекции.
Ожидание подключений и запросов от клиента.
Обработка полученных запросов (команд).
Сохранение коллекции в файл при завершении работы приложения.
Сохранение коллекции в файл при исполнении специальной команды, доступной только серверу (клиент такую команду отправить не может).
Серверное приложение должно состоять из следующих модулей (реализованных в виде одного или нескольких классов):
Модуль приёма подключений.
Модуль чтения запроса.
Модуль обработки полученных команд.
Модуль отправки ответов клиенту.
Сервер должен работать в однопоточном режиме.


Обязанности клиентского приложения:

Чтение команд из консоли.
Валидация вводимых данных.
Сериализация введённой команды и её аргументов.
Отправка полученной команды и её аргументов на сервер.
Обработка ответа от сервера (вывод результата исполнения команды в консоль).
Команду save из клиентского приложения необходимо убрать.
Команда exit завершает работу клиентского приложения.
Важно! Команды и их аргументы должны представлять из себя объекты классов. Недопустим обмен "простыми" строками. Так, для команды add или её аналога необходимо сформировать объект, содержащий тип команды и объект, который должен храниться в вашей коллекции.




7 ЛАБОРАТОРНАЯ

Доработать программу из лабораторной работы №6 следующим образом:

Организовать хранение коллекции в реляционной СУБД (PostgresQL).
Убрать хранение коллекции в файле.
Для генерации поля id использовать средства базы данных (sequence).
Обновлять состояние коллекции в памяти только при успешном добавлении объекта в БД
Все команды получения данных должны работать с коллекцией в памяти, а не в БД
Организовать возможность регистрации и авторизации пользователей.
У пользователя есть возможность указать пароль.
Пароли при хранении хэшировать алгоритмом MD5
Запретить выполнение команд не авторизованным пользователям.
При хранении объектов сохранять информацию о пользователе, который создал этот объект.
Пользователи должны иметь возможность просмотра всех объектов коллекции,
но модифицировать могут только принадлежащие им.
Для идентификации пользователя отправлять логин и пароль с каждым запросом.
Необходимо реализовать многопоточную обработку запросов.

Для многопоточного чтения запросов использовать создание нового потока (java.lang.Thread)
Для многопотчной обработки полученного запроса использовать Cached thread pool
Для многопоточной отправки ответа использовать Fixed thread pool
Для синхронизации доступа к коллекции использовать синхронизацию чтения и записи
с помощью java.util.concurrent.locks.ReentrantLock

Порядок выполнения работы:

В качестве базы данных использовать PostgreSQL.
Для подключения к БД на кафедральном сервере использовать хост pg,
имя базы данных - studs, имя пользователя/пароль совпадают с таковыми для подключения к серверу.